---
layout: post
title: Making the most of your docstrings
date: 2021-02-20 21:12:00 +0100
author: Charles Tapley Hoyt
tags: python
---
Writing excellent documentation is crucial for open source software projects. It's also a *lot* of
hard work. I consider tools like [Sphinx](https://www.sphinx-doc.org) combine with services
like [ReadTheDocs](https://readthedocs.org/) completely invaluable, but I've recently hit a
roadblock when it comes to making the README of a GitHub repository a bit more dynamic. This blog
post is about the dark magic I invented to support this.

This journey will be told through my work on the documentation of
[PyKEEN](https://github.com/pykeen/pykeen/), a machine learning library for learning low-dimensional
embeddings for nodes and edges in knowledge graphs. In this blog post, you don't need to understand
anything about the package itself other than it has several types of interchangable components that
can be combined to create a "model" that gets trained on a dataset. The documentation uses the
[`sphinx-automodapi`](https://sphinx-automodapi.readthedocs.io) extension to generate pretty lists
of all the datasets, models, loss functions, regularizers, etc.

The problem is that most people start by either looking at the README file in the GitHub repository,
or the splash text on the PyPI project page (which is for PyKEEN and most packages is created with
the README on upload). I wanted to generate beautiful tables describing the components on the README
file the same as in the Sphinx documentation, so I started by writing a template markdown file
using [`jinja`](https://jinja.palletsprojects.com) as a templating language. For each type of
component, I programatically built a table, formatted it as markdown
with [`tabulate`](https://pypi.org/project/tabulate/), and formatted it into the template.

The tricky part was making these tables better than just lists of the names of the classes. Sphinx
has a deep integration with the restructured text (RST) format and provides "directives"
like `:class:` that allow for automatic linking between documentation for modules, classes,
functions, variables, or anything else. Luckily, the
`sphinx-automodapi` uses a standard format for its documentation. For example,
the `pykeen.models.ComplEx` class gets built with a URL
like `https://pykeen.readthedocs.io/en/stable/api/pykeen.models.ComplEx.html`. The general form
for `<X>` is `https://pykeen.readthedocs.io/en/stable/api/<X>.html`. I was able to take advantage of
this and generate a column with the name of the class in PyKEEN with a link to the documentation for
the class on ReadTheDocs. This also gives insight to users who might want to import these classes
themselves.

The next tricky part was providing some context besides just the name and class name. For new users
looking at the models in PyKEEN, it's also useful to show a citation. This typically includes the
first author's last name and the year as in "Ali *et al.*, 2019". Additionally, the citation should
link to the paper itself for further reading past what the PyKEEN documentation for the model
provides (though it is one of my goals for PyKEEN's documentation to be an educational resource that
in many cases will be more useful than reading manuscripts written by computer scientists, whose
goals are to make themselves smart more than to motivate and educate the reader). In RST, there's a
syntax for linking citations that are all organized in
a [documentation-wide bibliography](https://pykeen.readthedocs.io/en/stable/references.html).
Unfortunately, the templating system is not as heavy as sphinx, and does not parse all of these
files. The solution I had was to standardize the citation keys and the format of the first line of
each model's docstring such that the name and year could be extracted with some simple text
processing because I enforced the standard that all model docstrings ended with the RST citation.

```python
from pykeen.models import ComplEx

doc = ComplEx.__doc__
doc_lines = doc.splitlines()
line = doc_lines[0]
l, r = line.find('['), line.find(']')
author, year = line[1 + l: r - 4], line[r - 4: r] 
```

Then the author and year could be formatted into a new column in the previous format. However,
programatically getting the citation link was a completely different problem. One solution I
considered was to start adding class variables with this information, but that would quickly become
a distraction to users.

Then, I remembered a cool feature of [`flasgger`](https://github.com/flasgger/flasgger/), which
automatically generates a Swagger interface for Flask applications by embedding the Swagger
definition as YAML inside
each [route's docstring](https://github.com/flasgger/flasgger/#using-docstrings-as-specification). I
didn't look into their code for an implementation and tried my own. The simple (but robust)
code that I wrote became the [`docdata`](https://github.com/cthoyt/docdata/) package. It does the
same thing as `flassger` - it allows the final few lines of a docstring to be parsed as YAML and
stored in the object. It can be applied as a decorator to functions and classes, or simply to any
data or python object that has a docstring. A demonstration shows it all:

```python
from docdata import parse_docdata, get_docdata


@parse_docdata
class MyClass:
    """This is my class.

    ---
    author: Charlie
    motto:
    - docs
    - are
    - cool
    """


assert {'author': 'Charlie', 'motto': ['docs', 'are', 'cool']} == get_docdata(MyClass)
```

This was immediately useful for PyKEEN models because I was able to store all the citation
information in a structured way at the bottom of the docstring. Then, I was able to improve my table
generator to make a much more rich column for citations that included the link to each. I also did
something for datasets in PyKEEN, but additionally included statistics about each dataset's
entities, relations, and triples to make the PyKEEN README even more useful. The full pull request
on PyKEEN can be found at [pykeen/pykeen!303](https://github.com/pykeen/pykeen/pull/303).
